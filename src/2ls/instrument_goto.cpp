/*******************************************************************\

Module: Instrument Goto Program with Inferred Information

Author: Peter Schrammel, Bj√∂rn Wachter

\*******************************************************************/

/// \file
/// Instrument Goto Program with Inferred Information

#include <util/string2int.h>

// #define DEBUG

#ifdef DEBUG
#include <iostream>
#endif

#include  "instrument_goto.h"

local_SSAt::locationt find_loop_by_guard(
  const local_SSAt &SSA,
  const symbol_exprt &guard)
{
  std::string gstr=id2string(guard.get_identifier());
  unsigned pos1=gstr.find("#")+1;
  unsigned pos2=gstr.find("%", pos1);
  unsigned n=safe_string2unsigned(gstr.substr(pos1, pos2));

  local_SSAt::nodest::const_iterator n_it=SSA.nodes.begin();

  for(; n_it!=SSA.nodes.end(); n_it++)
  {
    if(n_it->location->location_number==n)
    {
      // find end of loop
      break;
    }
  }

  if(n_it->loophead==SSA.nodes.end())
    return n_it->location;
  else
    return n_it->loophead->location;
}

void instrument_gotot::instrument_instruction(
  const exprt &expr,
  goto_programt &dest,
  goto_programt::targett &target)
{
  goto_programt::targett where=target;

#ifdef DEBUG
  std::cout << "target " << target->type << " : "
            << target->source_location << std::endl;
#endif

  for(; ; ++where)
  {
    if(where->is_goto() && where->get_target()==target)
      break;
  }

  goto_programt tmp;

  auto assumption=tmp.insert_after(
    target,
    goto_programt::make_assumption(expr, target->source_location));
  assumption->source_location.set_comment("invariant generated by 2LS");

  dest.insert_before_swap(where, tmp);

#ifdef DEBUG
  std::cout << "instrumenting instruction " << std::endl;
#endif
}

extern void purify_identifiers(exprt &expr);

void instrument_gotot::instrument_body(
  const local_SSAt &SSA,
  const symbol_exprt &guard,
  const exprt &expr,
  goto_functionst::goto_functiont &function)
{
  // copy the invariant so that it isn't changed by purify_identifiers
  exprt inv=expr;
  std::cout << "Invariant " << from_expr(SSA.ns, "", inv) << std::endl;

  purify_identifiers(inv);

  auto loc=find_loop_by_guard(SSA, guard);

  Forall_goto_program_instructions(it, function.body)
  {
    if(it==loc)
    {
      instrument_instruction(inv, function.body, it);
      break;
    }
  }
}

void instrument_gotot::instrument_function(
  const irep_idt &function_name,
  goto_functionst::goto_functiont &function)
{
  #ifdef DEBUG
  std::cout << "instrumenting function " << function_name << std::endl;
  #endif

  if(!summary_db.exists(function_name))
    return;

  const summaryt &summary=summary_db.get(function_name);

  if(!ssa_db.exists(function_name))
    return;

  const local_SSAt &SSA=ssa_db.get(function_name);

  if(summary.fw_invariant.is_nil())
    return;
  if(summary.fw_invariant.is_true())
    return;

  std::vector<domaint::guard_invariant> inv=
    summary.fw_domain_ptr->get_guards_and_invariants(*summary.fw_value_ptr);
  for(auto const &guard_invariant : inv)
  {
    const symbol_exprt &guard=to_symbol_expr(guard_invariant.first);
    exprt invariant=guard_invariant.second;
    instrument_body(SSA, guard, invariant, function);
  }
}

void instrument_gotot::operator()(goto_modelt &goto_model)
{
  goto_functionst &goto_functions=goto_model.goto_functions;

  goto_functionst::function_mapt  &function_map=goto_functions.function_map;

  for(auto & fit : function_map)
  {
    instrument_function(fit.first, fit.second);
  }

  goto_model.goto_functions.update();
}
